package jetbrains.mps.editor.multiline.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Property;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.nodeEditor.style.Style;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.openapi.editor.cells.KeyMap;
import jetbrains.mps.editor.runtime.cells.KeyMapImpl;
import jetbrains.mps.openapi.editor.cells.CellAction;
import javax.swing.SwingUtilities;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import java.awt.event.KeyEvent;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.nodeEditor.selection.EditorCellLabelSelection;
import jetbrains.mps.nodeEditor.cells.TextLine;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.cells.CellConditions;
import java.awt.Rectangle;
import jetbrains.mps.nodeEditor.cells.EditorCell_Label;
import org.apache.commons.lang3.StringUtils;
import jetbrains.mps.editor.multiline.runtime.CellUtils;
import org.apache.commons.lang3.StringEscapeUtils;
import java.awt.event.MouseEvent;
import jetbrains.mps.smodel.NodeReadAccessInEditorListener;
import jetbrains.mps.util.Pair;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.mps.nodeEditor.cells.PropertyAccessor;

public class EditorCell_Word extends EditorCell_Property {
  private int myWordNum;
  private int lastMLCaretPosition;
  private boolean myShiftSelectionDisabled = false;

  private boolean myDisableInsertOverride;


  public EditorCell_Word(EditorContext context, ModelAccessor modelAccessor, SNode node, int wordNum) {
    super(context, modelAccessor, node);
    myWordNum = wordNum;
    setEditable(true);
    setDefaultText("");
    Style style = this.getStyle();
    setAction(CellActionType.INSERT, new NewLineAction(this));
    setAction(CellActionType.INSERT_BEFORE, new NewLineAction(this));
    setAction(CellActionType.SELECT_LEFT, new SelectLeftRightAction(true, this));
    setAction(CellActionType.SELECT_RIGHT, new SelectLeftRightAction(false, this));
    setAction(CellActionType.SELECT_UP, new SelectUpDownAction(this, true));
    setAction(CellActionType.SELECT_PREVIOUS, new SelectUpDownAction(this, true));
    setAction(CellActionType.SELECT_DOWN, new SelectUpDownAction(this, false));
    setAction(CellActionType.SELECT_NEXT, new SelectUpDownAction(this, false));
    setAction(CellActionType.PASTE, new WordPasteAction(this));
    KeyMap km = new KeyMapImpl();
    // <node> 
    addKeyMap(km);
  }

  @Override
  public CellAction getAction(CellActionType type) {
    if (type == CellActionType.INSERT) {
      myDisableInsertOverride = true;
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          myDisableInsertOverride = false;
        }
      });
    }
    return super.getAction(type);
  }

  public void setIndentLayoutNewLine(boolean value) {
    getStyle().set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, value);
  }

  @Override
  protected boolean doProcessKeyTyped(KeyEvent event, boolean b) {
    lastMLCaretPosition = -1;
    boolean result = super.doProcessKeyTyped(event, b);
    if (lastMLCaretPosition != -1 && lastMLCaretPosition != getParent().getCaretPosition()) {
      getParent().setCaretPosition(lastMLCaretPosition);
    }
    return result;
  }

  public void setNewLine(boolean newLine) {
    setIndentLayoutNewLine(newLine);
  }

  public boolean followedByNewLine() {
    Boolean result = getStyle().get(StyleAttributes.INDENT_LAYOUT_NEW_LINE);
    result = (result == null ? false : result);
    return result;
  }

  @Override
  public String getText() {
    String text = super.getText();
    return (text == null ? "" : text);
  }

  public String getTextIncludingSeparator() {
    return getText() + ((followedByNewLine() ? "\n" : " "));
  }

  public int getTextLengthIncludingSeparator() {
    return getText().length() + 1;
  }

  @Override
  public boolean canPasteText() {
    return isEditable();
  }

  @Override
  protected boolean toShowCaret() {
    if (super.toShowCaret()) {
      return true;
    }

    // Caret blinking when multiline selection is active 
    Selection deepest = getEditor().getSelectionManager().getDeepestSelection();
    if (deepest instanceof EditorCellLabelSelection) {
      return ((EditorCellLabelSelection) deepest).getEditorCellLabel() == this && myCaretIsVisible;
    }

    return false;
  }

  public TextLine getRenderedTextLine() {
    TextLine textLine;
    if (myNoTextSet && myTextLine.getText().length() == 0) {
      textLine = myNullTextLine;
    } else {
      textLine = myTextLine;
    }
    return textLine;
  }

  @Override
  public void setCaretX(int x) {
    EditorCell rightLeaf = getLeafToRight(CellConditions.SELECTABLE);
    if (rightLeaf instanceof EditorCell_Word) {
      EditorCell_Word rightWord = ((EditorCell_Word) rightLeaf);
      if (rightWord.getX() - x < x - (getX() + getEffectiveWidth()) || isEmptyString(getText()) && x > getX()) {
        getEditor().getSelectionManager().setSelection(rightWord, 0);
        return;
      }
    }
    super.setCaretX(x);
  }

  public Rectangle getCharacterBounds(int charNum) {
    if (charNum < 0 || charNum > myTextLine.getText().length()) {
      throw new IllegalArgumentException("charNum = " + charNum + ", text = " + myTextLine.getText());
    }
    int prevPos = myTextLine.getCaretPosition();
    myTextLine.setCaretPosition(charNum);
    int x1 = myTextLine.getCaretX(myX + myGapLeft);
    myTextLine.setCaretPosition(charNum + 1);
    int x2 = myTextLine.getCaretX(myX + myGapLeft);
    Rectangle rect = new Rectangle();
    rect.setBounds(x1, getY(), x2 - x1, getHeight());

    // space/newline at end of word 
    if (charNum == myTextLine.getText().length()) {
      rect.width = myTextLine.getFontMetrics().charWidth(' ');
    }

    myTextLine.setCaretPosition(prevPos);
    return rect;
  }

  @Override
  public void setText(String text) {
    super.setText(text);
  }

  @Override
  public boolean executeTextAction(CellActionType type, boolean allowErrors) {
    if (type == CellActionType.BACKSPACE) {
      if (getCaretPosition() == 0) {
        if (isCursorAtMultilineStart()) {
          EditorCell prevLeaf = getPrevLeaf();
          if (prevLeaf != null) {
            if (prevLeaf instanceof EditorCell_Label) {
              EditorCell_Label labelCell = ((EditorCell_Label) prevLeaf);
              labelCell.setCaretPositionIfPossible(StringUtils.length(labelCell.getText()));
              CellUtils.setSelection(labelCell, getContext());
              labelCell.executeTextAction(CellActionType.BACKSPACE, allowErrors);
            }
          }
        } else {
          deletePrecedingCharacter();
        }
        return true;
      }
    } else if (type == CellActionType.INSERT) {
      insertText("\n");
    } else if (type == CellActionType.DELETE) {
      if (getCaretPosition() == getText().length()) {
        if (isCursorAtMultilineEnd()) {
          EditorCell nextLeaf = getNextLeaf();
          if (nextLeaf != null) {
            if (nextLeaf instanceof EditorCell_Label) {
              EditorCell_Label labelCell = ((EditorCell_Label) nextLeaf);
              labelCell.setCaretPositionIfPossible(0);
              CellUtils.setSelection(labelCell, getContext());
              labelCell.executeTextAction(CellActionType.DELETE, allowErrors);
            }
          }
        } else {
          deleteFollowingCharacter();
        }
        return true;
      }
    }
    boolean result = super.executeTextAction(type, allowErrors);
    return result;
  }

  public void deleteFollowingCharacter() {
    EditorCell_Multiline mlCell = this.getParent();
    if (mlCell != null) {
      int caretPos = mlCell.getCaretPosition();
      String text = mlCell.getTextAfterCaret();
      if (text.length() >= 1) {
        text = text.substring(1);
      }
      text = mlCell.getTextBeforeCaret() + text;
      mlCell.setText(text);
      mlCell.setCaretPosition(caretPos, true);
    }
  }

  public boolean isCursorAtMultilineStart() {
    EditorCell_Multiline mlCell = this.getParent();
    if (mlCell == null) {
      return false;
    }
    int caretPos = mlCell.getCaretPosition();
    return caretPos == 0;
  }

  public boolean isCursorAtMultilineEnd() {
    EditorCell_Multiline mlCell = this.getParent();
    if (mlCell == null) {
      return false;
    }
    int caretPos = mlCell.getCaretPosition();
    return caretPos == StringUtils.length(mlCell.getText());
  }

  private void deletePrecedingCharacter() {
    EditorCell_Multiline mlCell = this.getParent();
    if (mlCell != null) {
      int caretPos = mlCell.getCaretPosition();
      if (caretPos > 0) {
        String text = mlCell.getTextBeforeCaret();
        if (text.length() > 0) {
          text = text.substring(0, text.length() - 1);
        }
        text += mlCell.getTextAfterCaret();
        mlCell.setText(text);
        mlCell.setCaretPosition(caretPos - 1, true);
      }
    }
  }

  public void insertText(String text) {
    text = StringEscapeUtils.unescapeJava(text);
    EditorCell_Multiline mlCell = getParent();
    if (mlCell != null) {
      int newCaretPos = mlCell.getCaretPosition() + text.length();
      super.insertText(text);
      mlCell.setCaretPosition(newCaretPos);
    }
  }

  @Override
  public String getCellId() {
    return check_xru0dp_a0a0a72(getParent(), this) + "_word" + myWordNum;
  }

  @Override
  public EditorCell_Multiline getParent() {
    if (myDisableInsertOverride) {
      myDisableInsertOverride = false;
      return null;
    }
    return (EditorCell_Multiline) super.getParent();
  }

  @Override
  public void setCaretPositionIfPossible(int i) {
    if (i == getText().length() + 1) {
      int pos = getParent().getTextBefore(this, getText().length()).length() + 1;
      getParent().setCaretPosition(pos);
    } else {
      super.setCaretPositionIfPossible(i);
    }
    lastMLCaretPosition = getParent().getCaretPosition();
  }

  public String getTextBefore(int pos) {
    String result = getText();
    result = result.substring(0, Math.min(pos, result.length()));
    return result;
  }

  @Override
  public String getRole() {
    // This is required for processing the INSERT action (the user presses ENTER). 
    // Otherwise the action is passed to the next children collection cell. 
    return "";
  }

  @Override
  public void synchronizeViewWithModel() {
    check_xru0dp_a0a23(getParent(), this);
  }

  @Override
  public boolean processMousePressed(MouseEvent event) {
    super.processMousePressed(event);
    if (!(myShiftSelectionDisabled) && event.isShiftDown()) {
      int caretPos = getParent().getCaretPosition();
      getEditor().getSelectionManager().pushSelection(new MultilineSelection(getEditor(), getParent(), getParent().getRecentCursorPosition(0), caretPos));
    } else {
      getParent().rememberCursorPosition();
    }
    return true;
  }

  private static void addPropertyDependenciesToEditor(NodeReadAccessInEditorListener listener, EditorCell_Word result) {
    for (Pair pair : listener.popCleanlyReadAccessedProperties()) {
      result.getEditor().addCellDependentOnNodeProperty(result, pair);
    }
  }

  public static EditorCell_Word create(EditorContext editorContext, ModelAccessor modelAccessor, SNode node, int wordNum) {
    NodeReadAccessInEditorListener listener = NodeReadAccessCasterInEditor.getReadAccessListener();
    if (modelAccessor instanceof PropertyAccessor) {
      if (listener != null) {
        listener.clearCleanlyReadAccessProperties();
      }
    }
    EditorCell_Word result = new EditorCell_Word(editorContext, modelAccessor, node, wordNum);
    if (listener != null) {
      EditorCell_Word.addPropertyDependenciesToEditor(listener, result);
    }
    return result;
  }

  public Rectangle getBounds() {
    return new Rectangle(getX(), getY(), getWidth(), getHeight());
  }

  public void disableShiftSelection(boolean disable) {
    myShiftSelectionDisabled = disable;
  }

  private static String check_xru0dp_a0a0a72(EditorCell_Multiline checkedDotOperand, EditorCell_Word checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getCellId();
    }
    return null;
  }

  private static void check_xru0dp_a0a23(EditorCell_Multiline checkedDotOperand, EditorCell_Word checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      checkedDotOperand.synchronizeViewWithModel();
    }

  }

  private static boolean isEmptyString(String str) {
    return str == null || str.length() == 0;
  }
}
