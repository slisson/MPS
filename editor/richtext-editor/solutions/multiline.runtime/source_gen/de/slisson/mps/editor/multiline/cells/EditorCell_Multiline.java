package de.slisson.mps.editor.multiline.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Collection;
import jetbrains.mps.nodeEditor.cells.IPropertyCell;
import jetbrains.mps.nodeEditor.cells.IDiffPaintingCell;
import org.apache.log4j.Logger;
import jetbrains.mps.nodeEditor.cells.ModelAccessor;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.nodeEditor.cellLayout.CellLayout_Indent;
import de.slisson.mps.editor.multiline.runtime.MultilineUtil;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import org.apache.commons.lang3.StringUtils;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.apache.commons.lang3.ArrayUtils;
import de.slisson.mps.editor.multiline.runtime.CellUtils;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import java.awt.Rectangle;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import java.awt.Graphics;
import name.fraser.neil.plaintext.diff_match_patch;
import java.awt.Color;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.SortedSet;
import jetbrains.mps.internal.collections.runtime.SortedSetSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.awt.Shape;
import java.util.TreeSet;
import jetbrains.mps.nodeEditor.cells.PropertyAccessor;

public class EditorCell_Multiline extends EditorCell_Collection implements IPropertyCell, IDiffPaintingCell {
  private static final Logger LOG = Logger.getLogger(EditorCell_Multiline.class);
  private ModelAccessor myModelAccessor;
  private MultilineText myMultilineText;
  private List<WordCellInitializer> myWordCellInitializers = new ArrayList<WordCellInitializer>();
  private List<MultilineCellBackgroundPainter> myBackgroundPainters = new ArrayList<MultilineCellBackgroundPainter>();
  private boolean diffPaintingDisabled = false;
  private List<Integer> recentCursorPosition = ListSequence.fromList(new LinkedList<Integer>());

  protected EditorCell_Multiline(EditorContext context, ModelAccessor accessor, SNode node) {
    super(context, node, new CellLayout_Indent(), null);
    myModelAccessor = accessor;
    myMultilineText = new MultilineText(MultilineUtil.unescapeText(accessor.getText()));
    bindModel();

    getStyle().set(StyleAttributes.INDENT_LAYOUT_WRAP_INDENT_FACTOR, 0.0f);
    getStyle().set(StyleAttributes.INDENT_LAYOUT_FILL_LINES, true);
  }

  public void bindModel() {
    myMultilineText.addListener(MultilineText.PROPERTY_TEXT, new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent e) {
        final String newText = ((String) e.getNewValue());
        if (ModelAccess.instance().canWrite()) {
          textToProperty(newText);
        } else {
          getContext().executeCommand(new Runnable() {
            public void run() {
              textToProperty(newText);
            }
          });
        }
      }
    });
    myMultilineText.addListener(MultilineText.PROPERTY_WORDS, new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent e) {
        if (ModelAccess.instance().canWrite()) {
          modelToView();
        } else {
          getContext().executeCommand(new Runnable() {
            public void run() {
              modelToView();
            }
          });
        }
      }
    });
    modelToView();
  }

  @Override
  public void synchronizeViewWithModel() {
    myMultilineText.setTextSilently(MultilineUtil.unescapeText(myModelAccessor.getText()));
    modelToView();
  }

  protected void modelToView() {
    Iterable<String[]> lines = Sequence.fromArray(myMultilineText.getWords());
    int totalWords = Sequence.fromIterable(lines).select(new ISelector<String[], Integer>() {
      public Integer select(String[] it) {
        return it.length;
      }
    }).reduceLeft(new ILeftCombinator<Integer, Integer>() {
      public Integer combine(Integer a, Integer b) {
        return a + b;
      }
    });
    setNumberOfWordCells(totalWords);
    List<EditorCell_Word> wordCells = Sequence.fromIterable(getWordCells()).toListSequence();
    int wordNum = -1;
    for (String[] line : lines) {
      for (String word : line) {
        ++wordNum;
        EditorCell_Word wordCell = ListSequence.fromList(wordCells).getElement(wordNum);
        wordCell.setText(word);
        wordCell.setNewLine(false);
      }
      ListSequence.fromList(wordCells).getElement(wordNum).setNewLine(true);
    }
    ListSequence.fromList(wordCells).last().setNewLine(false);
  }

  public void textToProperty(String newText) {
    String oldText = myModelAccessor.getText();
    if (neq_v798xa_a0b0l(oldText, newText)) {
      myModelAccessor.setText(MultilineUtil.escapeText(newText));
    }
  }

  public void setNumberOfWordCells(int count) {
    while (getCellsCount() > count) {
      removeCell(Sequence.fromIterable(Sequence.fromArray(getCells())).last());
    }
    while (getCellsCount() < count) {
      addEditorCell(this.newWordCell(getCellsCount()));
    }
  }

  @Override
  public String toString() {
    return getClass().getSimpleName() + "[" + StringUtils.abbreviate(getText(), 30) + "]";
  }

  public int getCaretPosition() {
    int pos = 0;
    EditorCell selectedCell = getContext().getSelectedCell();
    if (selectedCell instanceof EditorCell_Word) {
      EditorCell_Word selectedWordCell = (EditorCell_Word) selectedCell;
      pos = Sequence.fromIterable(getCellsBefore(selectedWordCell)).foldLeft(0, new ILeftCombinator<EditorCell_Word, Integer>() {
        public Integer combine(Integer s, EditorCell_Word it) {
          return s + it.getTextIncludingSeparator().length();
        }
      });
      pos += selectedWordCell.getCaretPosition();
    }
    return pos;
  }

  public boolean isCaretAtLineStart() {
    return getTextBeforeCaret().endsWith("\n") || getCaretPosition() == 0;
  }

  public boolean isCaretAtWordStart() {
    boolean result = false;
    EditorCell selectedCell = getContext().getSelectedCell();
    if (selectedCell instanceof EditorCell_Word) {
      EditorCell_Word selectedWordCell = (EditorCell_Word) selectedCell;
      result = selectedWordCell.getCaretPosition() == 0;
    }
    return result;
  }

  public boolean isCaretAtWordEnd() {
    boolean result = false;
    EditorCell selectedCell = getContext().getSelectedCell();
    if (selectedCell instanceof EditorCell_Word) {
      EditorCell_Word selectedWordCell = (EditorCell_Word) selectedCell;
      result = selectedWordCell.getCaretPosition() == selectedWordCell.getText().length();
    }
    return result;
  }

  public void setCaretPosition(int pos) {
    setCaretPosition(pos, false);
  }

  public EditorCell_Word getWordCellContainingPos(int pos) {
    int remainingPos = pos;
    for (EditorCell_Word wordCell : Sequence.fromIterable(getWordCells())) {
      int textLen = wordCell.getText().length();
      if (remainingPos <= textLen) {
        return wordCell;
      }
      remainingPos -= textLen + 1;
    }
    return Sequence.fromIterable(getWordCells()).last();
  }

  public void setCaretPosition(int pos, boolean enforceSelection) {
    // If the EditorComponent is rebuild after a model modification, this cell might not be part of the component 
    // anymore. Therefor, we search for the new multiline cell and forward the call to that one. 
    getEditor().flushEvents();
    check_v798xa_a3a02(((EditorCell_Multiline) getCellInfo().findCell(getEditor())), pos, enforceSelection, this);
  }

  private void setCaretPosition_(int pos, boolean enforceSelection) {
    int remainingPos = pos;
    for (EditorCell_Word wordCell : Sequence.fromIterable(getWordCells())) {
      int textLen = wordCell.getText().length();
      if (remainingPos <= textLen) {
        if (enforceSelection || ArrayUtils.contains(getCells(), getContext().getSelectedCell())) {
          CellUtils.setSelection(wordCell, getContext());
        }
        wordCell.setCaretPositionIfPossible(remainingPos);
        break;
      }
      remainingPos -= textLen + 1;
    }
  }

  public void insertText(String text) {
    int caretPos = getCaretPosition();
    myMultilineText.setText(getTextBeforeCaret() + text + getTextAfterCaret());
    setCaretPosition(caretPos + text.length(), true);
  }

  public String getTextBefore(EditorCell_Word wordCell, int pos) {
    StringBuffer textBefore = new StringBuffer();
    Iterable<EditorCell_Word> cellsBefore = getCellsBefore(wordCell);
    if (Sequence.fromIterable(cellsBefore).isNotEmpty()) {
      textBefore.append(IterableUtils.join(Sequence.fromIterable(cellsBefore).select(new ISelector<EditorCell_Word, String>() {
        public String select(EditorCell_Word it) {
          return it.getTextIncludingSeparator();
        }
      }), ""));
    }
    textBefore.append(wordCell.getTextBefore(pos));

    return textBefore.toString();
  }

  public int getCellStartPosition(EditorCell_Word wordCell) {
    return getAbsoluteTextPosition(wordCell, 0);
  }

  public int getAbsoluteTextPosition(EditorCell_Word wordCell, int relativePos) {
    return StringUtils.length(getTextBefore(wordCell, relativePos));
  }

  public Iterable<EditorCell_Word> getCellsBefore(EditorCell_Word cell) {
    List<EditorCell_Word> result = ListSequence.fromList(new ArrayList<EditorCell_Word>());
    int cellNum = getCellNumber(cell);
    if (cellNum >= 0) {
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(getWordCells()).take(cellNum));
    }
    return result;
  }

  public String getTextBeforeCaret() {
    return myMultilineText.getText().substring(0, getCaretPosition());
  }

  public String getTextAfterCaret() {
    return myMultilineText.getText().substring(getCaretPosition());
  }

  public Iterable<EditorCell_Word> getWordCells() {
    return Sequence.fromIterable(Sequence.fromArray(getCells())).select(new ISelector<jetbrains.mps.nodeEditor.cells.EditorCell, EditorCell_Word>() {
      public EditorCell_Word select(jetbrains.mps.nodeEditor.cells.EditorCell it) {
        return (EditorCell_Word) it;
      }
    });
  }

  public String getText() {
    return myMultilineText.getText();
  }

  public void setText(String newText) {
    newText = check_v798xa_a0a0fb(newText);
    myMultilineText.setText(newText);
    modelToView();
  }

  public void deleteWords(int from, int to) {
    myMultilineText.deleteWords(from, to);
  }

  public EditorCell_Word newWordCell(int wordNum) {
    EditorCell_Word wordCell = EditorCell_Word.create(getEditorContext(), new WordModelAccessor(wordNum, myMultilineText), getSNode(), wordNum);
    for (WordCellInitializer initializer : ListSequence.fromList(myWordCellInitializers)) {
      initializer.initialize(wordCell);
    }
    return wordCell;
  }

  @Override
  public EditorCell_Word getCellAt(int i) {
    return (EditorCell_Word) super.getCellAt(i);
  }

  @Override
  public void addEditorCellAt(int i, EditorCell cell, boolean b) {
    if (!(cell instanceof EditorCell_Word)) {
      throw new IllegalArgumentException("Cells of type EditorCell_Word allowed only. Was of type: " + check_v798xa_a0a0a0a0jb(check_v798xa_a0a0a0a0a53(cell)));

    }
    super.addEditorCellAt(i, cell, b);
  }

  public int getTextLength() {
    return StringUtils.length(getText());
  }

  public void addWordCellInitializer(WordCellInitializer initializer) {
    myWordCellInitializers.add(initializer);
    for (EditorCell_Word wordCell : Sequence.fromIterable(getWordCells())) {
      initializer.initialize(wordCell);
    }
  }

  public void removeWordCellInitializer(WordCellInitializer initializer) {
    myWordCellInitializers.remove(initializer);
  }

  public List<WordCellInitializer> getWordCellInitializers() {
    return new ArrayList<WordCellInitializer>(myWordCellInitializers);
  }

  public Rectangle getCharacterBounds(int charNum) {
    EditorCell_Word wordCell = getWordCellContainingPos(charNum);
    int relativeNum = charNum - getAbsoluteTextPosition(wordCell, 0);
    relativeNum = Math.max(relativeNum, 0);
    relativeNum = Math.min(relativeNum, wordCell.getTextLengthIncludingSeparator() - 1);
    return wordCell.getCharacterBounds(relativeNum);
  }

  @Override
  public ParentSettings paintBackground(Graphics g, ParentSettings parentSettings) {
    ParentSettings result = super.paintBackground(g, parentSettings);

    for (MultilineCellBackgroundPainter painter : ListSequence.fromList(myBackgroundPainters)) {
      painter.paint(this, g, parentSettings);
    }

    return result;
  }

  public void paintDiff(Graphics g, String oldText, String newText, boolean iAmOld) {
    diff_match_patch differ = new diff_match_patch();
    java.util.LinkedList<diff_match_patch.Diff> diffsLL = (iAmOld ? differ.diff_main(newText, oldText) : differ.diff_main(oldText, newText));
    differ.diff_cleanupSemantic(diffsLL);
    Color colorInsert = new Color(214, 245, 214);
    Color colorDelete = new Color(203, 203, 203);
    Color colorChange = new Color(188, 207, 249);

    List<diff_match_patch.Diff> diffs = new ArrayList<diff_match_patch.Diff>(diffsLL);
    int start = 0;
    for (int i = 0; i < diffs.size(); i++) {
      diff_match_patch.Diff prevDiff = (i > 0 ? diffs.get(i - 1) : null);
      diff_match_patch.Diff diff = diffs.get(i);
      diff_match_patch.Diff nextDiff = (i < diffs.size() - 1 ? diffs.get(i + 1) : null);
      switch (diff.operation) {
        case EQUAL:
          start += diff.text.length();
          break;
        case DELETE:
          if (nextDiff != null && nextDiff.operation == diff_match_patch.Operation.INSERT) {
            continue;
          }
          Rectangle rect2 = getCharacterBounds(start);
          rect2.width = 4;
          rect2.y -= 1;
          rect2.height += 3;
          rect2.x -= 2;
          g.setColor((iAmOld ? colorInsert : colorDelete));
          g.fillRect(rect2.x, rect2.y, rect2.width, rect2.height);
          break;
        case INSERT:
          Color color = (iAmOld ? colorDelete : colorInsert);
          if (prevDiff != null && prevDiff.operation == diff_match_patch.Operation.DELETE) {
            color = colorChange;
          }
          paintRange(g, start, start + diff.text.length() - 1, color, true);
          start += diff.text.length();
          break;
        default:
      }
    }
  }

  public void paintRange(Graphics g, int start, int end, Color color, boolean border) {
    final Wrappers._int _start = new Wrappers._int(start);
    final Wrappers._int _end = new Wrappers._int(end);
    if (_start.value > _end.value) {
      int temp = _start.value;
      _start.value = _end.value;
      _end.value = temp;
    }
    SortedSet<Integer> lineEnds = findAllLineEnds();
    SortedSetSequence.fromSet(lineEnds).addElement(_end.value);

    int lineStart = _start.value;
    for (int lineEnd : SortedSetSequence.fromSet(lineEnds).where(new IWhereFilter<Integer>() {
      public boolean accept(Integer it) {
        return _start.value <= it && it <= _end.value;
      }
    })) {
      paintLine(g, lineStart, lineEnd, color, border);
      lineStart = lineEnd + 1;
    }
  }

  /**
   * precondition: the characters at 'start' and 'end' have to be on the same line
   */
  public void paintLine(Graphics g, int start, int end, Color color, boolean border) {
    Rectangle rect = getCharacterBounds(start).union(getCharacterBounds(end));
    g.setColor(color);
    g.fillRect(rect.x, rect.y, rect.width, rect.height);
    if (border) {
      g.setColor(color.darker());
      g.drawRect(rect.x, rect.y, rect.width, rect.height);
    }

    Shape originalClip = g.getClip();
    g.setClip(rect);
    int wordStartPos = 0;
    for (EditorCell_Word word : Sequence.fromIterable(getWordCells())) {
      int wordEndPos = wordStartPos + word.getTextLengthIncludingSeparator();
      if (wordEndPos >= start && wordStartPos <= end) {
        word.paint(g, ParentSettings.createSelectedSetting(true));
      }
      wordStartPos = wordEndPos;
    }
    g.setClip(originalClip);


  }

  public SortedSet<Integer> findAllLineEnds() {
    SortedSet<Integer> result = SortedSetSequence.fromSet(new TreeSet<Integer>());
    List<EditorCell_Word> wordCells = Sequence.fromIterable(getWordCells()).toListSequence();
    int start = 0;
    for (int i = 0; i < ListSequence.fromList(wordCells).count(); i++) {
      EditorCell_Word cell = ListSequence.fromList(wordCells).getElement(i);
      EditorCell_Word nextCell = (i < ListSequence.fromList(wordCells).count() - 1 ? ListSequence.fromList(wordCells).getElement(i + 1) : null);
      int textLen = cell.getTextIncludingSeparator().length();
      if (nextCell == null) {
        SortedSetSequence.fromSet(result).addElement(start + textLen - 1);
      } else {
        if (cell.getY() != nextCell.getY()) {
          SortedSetSequence.fromSet(result).addElement(start + textLen - 1);
        }
      }
      start += textLen;
    }
    return result;
  }

  public void addBackgroundPainter(MultilineCellBackgroundPainter painter) {
    myBackgroundPainters.add(painter);
  }

  public void disabledDiffPainting() {
    diffPaintingDisabled = true;
  }

  public void rememberCursorPosition() {
    rememberCursorPosition(getCaretPosition());
  }

  public void rememberCursorPosition(int pos) {
    ListSequence.fromList(recentCursorPosition).insertElement(0, pos);
    while (ListSequence.fromList(recentCursorPosition).count() > 10) {
      ListSequence.fromList(recentCursorPosition).removeLastElement();
    }
  }

  public int getRecentCursorPosition(int age) {
    if (ListSequence.fromList(recentCursorPosition).count() == 0) {
      return 0;
    } else if (age < 0) {
      return ListSequence.fromList(recentCursorPosition).first();
    } else if (age >= ListSequence.fromList(recentCursorPosition).count()) {
      return ListSequence.fromList(recentCursorPosition).last();
    } else {
      return ListSequence.fromList(recentCursorPosition).getElement(age);
    }
  }

  public static EditorCell_Multiline create(EditorContext context, ModelAccessor accessor, SNode node) {
    EditorCell_Multiline result = new EditorCell_Multiline(context, accessor, node);
    return result;
  }

  public String getPropertyName() {
    if (myModelAccessor instanceof PropertyAccessor) {
      return ((PropertyAccessor) myModelAccessor).getPropertyName();
    }
    return null;
  }

  public void paintPropertyChange(Graphics g, String name, String oldValue, String newValue) {
    newValue = MultilineUtil.unescapeText(newValue);
    oldValue = MultilineUtil.unescapeText(oldValue);
    boolean iAmOld = neq_v798xa_a0a2a35(getText(), newValue);
    paintDiff(g, oldValue, newValue, iAmOld);
  }

  private static void check_v798xa_a3a02(EditorCell_Multiline checkedDotOperand, int pos, boolean enforceSelection, EditorCell_Multiline checkedDotThisExpression) {
    if (null != checkedDotOperand) {
      checkedDotOperand.setCaretPosition_(pos, enforceSelection);
    }

  }

  private static String check_v798xa_a0a0fb(String checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.replace("\\n", "\n");
    }
    return null;
  }

  private static String check_v798xa_a0a0a0a0jb(Class<?> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getName();
    }
    return null;
  }

  private static Class<?> check_v798xa_a0a0a0a0a53(EditorCell checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getClass();
    }
    return null;
  }

  private static boolean neq_v798xa_a0b0l(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }

  private static boolean neq_v798xa_a0a2a35(Object a, Object b) {
    return !((a != null ? a.equals(b) : a == b));
  }
}
