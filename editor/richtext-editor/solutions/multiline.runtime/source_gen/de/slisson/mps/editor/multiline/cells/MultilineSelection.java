package de.slisson.mps.editor.multiline.cells;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.selection.AbstractSelection;
import org.apache.log4j.Logger;
import jetbrains.mps.openapi.editor.EditorComponent;
import java.util.Map;
import jetbrains.mps.nodeEditor.cells.CellInfo;
import jetbrains.mps.openapi.editor.selection.SelectionStoreException;
import jetbrains.mps.nodeEditor.selection.SelectionRestoreException;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.nodeEditor.selection.SelectionInfoImpl;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import de.slisson.mps.editor.multiline.runtime.ClipboardUtils;
import jetbrains.mps.nodeEditor.cells.CellConditions;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.openapi.editor.selection.SelectionManager;
import jetbrains.mps.openapi.editor.selection.Selection;
import jetbrains.mps.openapi.editor.selection.SingularSelection;
import jetbrains.mps.openapi.editor.selection.SelectionInfo;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import java.awt.Graphics2D;
import java.awt.Color;
import com.intellij.openapi.editor.colors.EditorColorsManager;
import com.intellij.openapi.editor.colors.EditorColors;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import java.util.Collections;
import org.jetbrains.mps.openapi.model.SNode;

public class MultilineSelection extends AbstractSelection {
  private static final Logger LOG = Logger.getLogger(MultilineSelection.class);
  private static final String PROPERTY_SELECTION_START = "selectionStart";
  private static final String PROPERTY_SELECTION_END = "selectionEnd";

  private EditorCell_Multiline myMultilineCell;
  private int mySelectionStart;
  /**
   * can be lower than mySelectionStart
   */
  private int mySelectionEnd;


  public MultilineSelection(EditorComponent editorComponent, Map<String, String> properties, CellInfo cellInfo) throws SelectionStoreException, SelectionRestoreException {
    super(editorComponent);
    if (cellInfo == null) {
      throw new SelectionStoreException("Required CellInfo parameter is null");
    }
    EditorCell editorCell = cellInfo.findCell(((jetbrains.mps.nodeEditor.EditorComponent) editorComponent));
    if (editorCell instanceof EditorCell_Multiline) {
      myMultilineCell = (EditorCell_Multiline) editorCell;
    } else {
      throw new SelectionRestoreException();
    }
    int start = SelectionInfoImpl.Util.getIntProperty(properties, PROPERTY_SELECTION_START);
    int end = SelectionInfoImpl.Util.getIntProperty(properties, PROPERTY_SELECTION_END);
    setSelectionRange(start, end);
  }

  public MultilineSelection(EditorComponent editorComponent, EditorCell_Multiline multilineCell, int start, int end) {
    super(editorComponent);
    myMultilineCell = multilineCell;
    setSelectionRange(start, end);
  }

  public void setSelectionStart(int newValue) {
    setSelectionRange(newValue, mySelectionEnd);
  }

  public int getSelectionStart() {
    return mySelectionStart;
  }

  public int getSelectionEnd() {
    return mySelectionEnd;
  }

  public void setSelectionEnd(int newValue) {
    setSelectionRange(mySelectionStart, newValue);
  }

  public void setSelectionRange(int selStart, int selEnd) {
    mySelectionStart = selStart;
    mySelectionEnd = selEnd;
  }

  public EditorCell_Multiline getMultilineCell() {
    return myMultilineCell;
  }

  public void updateVisibleSelection(int selStart, int selEnd) {
    int caretPos = selEnd;
    if (selStart > selEnd) {
      int temp = selStart;
      selStart = selEnd;
      selEnd = temp;
    }
    int wordStart = 0;
    for (EditorCell_Word wordCell : Sequence.fromIterable(myMultilineCell.getWordCells())) {
      int wordLength = wordCell.getText().length();
      int wordEnd = wordStart + wordLength;
      if (wordStart <= caretPos && caretPos <= wordEnd && selEnd != selStart) {
        wordCell.setCaretPosition(caretPos - wordStart);
      }
      wordCell.setSelectionStart(limitValue(selStart - wordStart, 0, wordLength));
      wordCell.setSelectionEnd(limitValue(selEnd - wordStart, 0, wordLength));
      wordStart += wordCell.getTextIncludingSeparator().length();
    }
  }

  public void activate() {
    jetbrains.mps.nodeEditor.EditorComponent component = (jetbrains.mps.nodeEditor.EditorComponent) getEditorComponent();
    component.pushKeyboardHandler(new SelectionKeyboardHandler(this, component.peekKeyboardHandler()));
    component.repaint();
  }

  public void deactivate() {
    jetbrains.mps.nodeEditor.EditorComponent component = (jetbrains.mps.nodeEditor.EditorComponent) getEditorComponent();
    component.popKeyboardHandler();
    updateVisibleSelection(0, 0);
  }

  public void ensureVisible() {
    EditorCell caretCell = myMultilineCell.getWordCellContainingPos(mySelectionEnd);
    if (caretCell == null) {
      return;
    }
    getEditorComponent().scrollToCell(caretCell);
  }

  @Override
  public void executeAction(CellActionType type) {
    if (CellActionType.SELECT_LEFT == type || CellActionType.SELECT_RIGHT == type) {
      int newEnd = (type == CellActionType.SELECT_LEFT ? mySelectionEnd - 1 : mySelectionEnd + 1);
      changeSelection(newEnd);
    } else if (type == CellActionType.DELETE || type == CellActionType.BACKSPACE) {
      executeDeleteSelectedText();
    } else if (type == CellActionType.COPY) {
      ClipboardUtils.setClipboardText(getSelectedText());
    } else if (type == CellActionType.CUT) {
      executeAction(CellActionType.COPY);
      executeDeleteSelectedText();
    } else if (type == CellActionType.PASTE) {
      pasteClipboardText();
    } else if (type == CellActionType.SELECT_PREVIOUS || type == CellActionType.SELECT_UP) {
      selectUpOrDown(true);
    } else if (type == CellActionType.SELECT_NEXT || type == CellActionType.SELECT_DOWN) {
      selectUpOrDown(false);
    } else if (type == CellActionType.LEFT || type == CellActionType.RIGHT || type == CellActionType.DOWN || type == CellActionType.UP) {
      clearSelection();
    } else {
      LOG.info("unhandled action: " + type);
    }
  }

  @Override
  public boolean canExecuteAction(CellActionType type) {
    switch (type) {
      case SELECT_LEFT:
      case SELECT_RIGHT:
      case DELETE:
      case BACKSPACE:
      case COPY:
      case CUT:
      case PASTE:
      case SELECT_PREVIOUS:
      case SELECT_UP:
      case SELECT_NEXT:
      case SELECT_DOWN:
      case LEFT:
      case RIGHT:
      case DOWN:
      case UP:
        return true;
      default:
        return false;
    }
  }



  public String getSelectedText() {
    int first = Math.min(mySelectionStart, mySelectionEnd);
    int last = Math.max(mySelectionStart, mySelectionEnd);
    return myMultilineCell.getText().substring(first, last);
  }

  public void clearSelection() {
    int caretPos = mySelectionEnd;
    setSelectionRange(caretPos, caretPos);
    myMultilineCell.setCaretPosition(caretPos, true);
  }

  public void pasteClipboardText() {
    replaceSelectedText(ClipboardUtils.getClipboardText());
  }

  public void replaceSelectedText(final String text) {
    getEditorComponent().getEditorContext().executeCommand(new Runnable() {
      public void run() {
        deleteSelectedText();
        myMultilineCell.insertText(text);
      }
    });
  }

  public void selectUpOrDown(boolean up) {
    EditorCell_Word cursorCell = myMultilineCell.getWordCellContainingPos(mySelectionEnd);
    cursorCell.setCaretPosition(mySelectionEnd - myMultilineCell.getCellStartPosition(cursorCell));
    EditorCell upperOrLower = (up ? cursorCell.getUpper(CellConditions.SELECTABLE, cursorCell.getCaretX()) : cursorCell.getLower(CellConditions.SELECTABLE, cursorCell.getCaretX()));
    if (!(upperOrLower instanceof EditorCell_Word)) {
      return;
    }
    EditorCell_Word upperOrLowerWordCell = (EditorCell_Word) upperOrLower;
    if (upperOrLowerWordCell.getParent() != myMultilineCell) {
      return;
    }

    upperOrLowerWordCell.setCaretX(cursorCell.getCaretX());
    int newEnd = myMultilineCell.getTextBefore(upperOrLowerWordCell, upperOrLowerWordCell.getCaretPosition()).length();
    changeSelection(newEnd);
  }

  public void executeDeleteSelectedText() {
    if (ModelAccess.instance().canWrite()) {
      deleteSelectedText();
    } else {
      getEditorComponent().getEditorContext().executeCommand(new Runnable() {
        public void run() {
          deleteSelectedText();
        }
      });
    }
  }

  public void deleteSelectedText() {
    int first = Math.min(mySelectionStart, mySelectionEnd);
    int last = Math.max(mySelectionStart, mySelectionEnd);
    String text = myMultilineCell.getText();
    text = text.substring(0, first) + text.substring(last, text.length());
    myMultilineCell.setText(text);
    setSelectionRange(0, 0);
    myMultilineCell.setCaretPosition(first, true);
  }

  private void changeSelection(int newEnd) {
    if (newEnd < 0 || newEnd > myMultilineCell.getTextLength()) {
      return;
    }
    SelectionManager selectionManager = getEditorComponent().getSelectionManager();
    Selection newSelection;
    if (newEnd != mySelectionEnd) {
      newSelection = new MultilineSelection(getEditorComponent(), myMultilineCell, mySelectionStart, newEnd);
    } else {
      newSelection = selectionManager.createSelection(myMultilineCell.getParent());
      if (newSelection instanceof SingularSelection) {
        ((SingularSelection) newSelection).setSideSelectDirection((mySelectionStart > newEnd ? SingularSelection.SideSelectDirection.LEFT : SingularSelection.SideSelectDirection.RIGHT));
      }
    }
    selectionManager.setSelection(newSelection);
  }

  public SelectionInfo getSelectionInfo() throws SelectionStoreException {
    SelectionInfoImpl selectionInfo = new SelectionInfoImpl(this.getClass().getName(), PersistenceFacade.getInstance().createModuleReference("dc038ceb-b7ea-4fea-ac12-55f7400e97ba(de.slisson.mps.editor.multiline.runtime)").getModuleName());
    selectionInfo.setCellInfo(myMultilineCell.getCellInfo());
    selectionInfo.getPropertiesMap().put(PROPERTY_SELECTION_START, Integer.toString(mySelectionStart));
    selectionInfo.getPropertiesMap().put(PROPERTY_SELECTION_END, Integer.toString(mySelectionEnd));
    return selectionInfo;
  }

  public boolean isSame(Selection other) {
    if (this == other) {
      return true;
    }
    if (other == null || getClass() != other.getClass()) {
      return false;
    }
    MultilineSelection otherSelection = (MultilineSelection) other;
    if (!(myMultilineCell.equals(otherSelection.myMultilineCell))) {
      return false;
    }
    if (mySelectionStart != otherSelection.mySelectionStart) {
      return false;
    }
    if (mySelectionEnd != otherSelection.mySelectionEnd) {
      return false;
    }
    return true;
  }

  public void paintSelection(Graphics2D g) {
    Color color = EditorColorsManager.getInstance().getGlobalScheme().getColor(EditorColors.SELECTION_BACKGROUND_COLOR);
    int first = Math.min(mySelectionStart, mySelectionEnd);
    int last = Math.max(mySelectionStart, mySelectionEnd) - 1;
    myMultilineCell.paintRange(g, first, last, color, true);
  }

  public int getCaretPosition() {
    return mySelectionEnd;
  }

  public EditorCell_Word getCellContainingCaret() {
    return myMultilineCell.getWordCellContainingPos(getCaretPosition());
  }

  public static int limitValue(int value, int min, int max) {
    int result = value;
    result = Math.min(result, max);
    result = Math.max(result, min);
    return result;
  }

  @NotNull
  @Override
  public List<EditorCell> getSelectedCells() {
    return Collections.singletonList((EditorCell) myMultilineCell);
  }

  @NotNull
  @Override
  public List<SNode> getSelectedNodes() {
    return Collections.singletonList(myMultilineCell.getSNode());
  }
}
