package jetbrains.mps.editor.richtext.runtime.selection;

/*Generated by MPS */

import jetbrains.mps.editor.runtime.cells.AbstractCellAction;
import jetbrains.mps.editor.multiline.cells.EditorCell_Word;
import jetbrains.mps.openapi.editor.EditorContext;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.datatransfer.CopyPasteUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.editor.richtext.behavior.Word_Behavior;
import javax.swing.SwingUtilities;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.editor.multiline.cells.EditorCell_Multiline;
import jetbrains.mps.openapi.editor.cells.CellTraversalUtil;
import jetbrains.mps.editor.multiline.runtime.ClipboardUtils;

public class RichtextPasteAction extends AbstractCellAction {
  private EditorCell_Word myWordCell;

  public RichtextPasteAction(EditorCell_Word wordCell) {
    myWordCell = wordCell;
  }

  public void execute(final EditorContext context) {
    final List<SNode> nodes = CopyPasteUtil.getNodesFromClipboard(context.getEditorComponent().getEditedNode().getModel());
    final SNode wordNode = (SNode) myWordCell.getSNode();
    boolean allAreIWords = ListSequence.fromList(nodes).foldLeft(true, new ILeftCombinator<SNode, Boolean>() {
      public Boolean combine(Boolean s, SNode it) {
        return s && SNodeOperations.isInstanceOf(it, "jetbrains.mps.editor.richtext.structure.IWord");
      }
    });

    if (ListSequence.fromList(nodes).isNotEmpty() && allAreIWords) {
      final Wrappers._T<Integer> caretPos = new Wrappers._T<Integer>(check_j8mhr4_a0a0e0c(SNodeOperations.as(ListSequence.fromList(nodes).last(), "jetbrains.mps.editor.richtext.structure.Word")));
      if (caretPos.value == null) {
        caretPos.value = 0;
      }
      Word_Behavior.call_insertNodesAtCaret_5696298824709660031(wordNode, nodes, context);
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          EditorCell lastCell = context.getEditorComponent().findNodeCell(ListSequence.fromList(nodes).last());
          if (!(lastCell instanceof EditorCell_Multiline)) {
            lastCell = (lastCell == null ? null : CellTraversalUtil.getNextSibling(lastCell));
          }
          if (lastCell instanceof EditorCell_Multiline) {
            ((EditorCell_Multiline) lastCell).setCaretPosition(caretPos.value, true);
          }
        }
      });
    } else {
      String text = ClipboardUtils.getClipboardText();
      final int caretPos = Word_Behavior.call_getCaretPosition_1212807527450953743(wordNode, context) + text.length();
      Word_Behavior.call_insertTextAtCaret_2557074442922687324(wordNode, text, context);
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          EditorCell mlCell = context.getEditorComponent().findNodeCell(wordNode);
          if (mlCell instanceof EditorCell_Multiline) {
            ((EditorCell_Multiline) mlCell).setCaretPosition(caretPos, true);
          }
        }
      });
    }
  }

  private static int check_j8mhr4_a0a0e0c(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return Word_Behavior.call_getTextLength_6973228588407182844(checkedDotOperand);
    }
    return 0;
  }
}
