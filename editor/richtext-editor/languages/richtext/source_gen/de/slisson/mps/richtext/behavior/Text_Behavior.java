package de.slisson.mps.richtext.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;

public class Text_Behavior {
  public static void init(SNode thisNode) {
    SLinkOperations.addNewChild(thisNode, "words", "de.slisson.mps.richtext.structure.Word");
  }

  public static void call_normalizeStructure_5500395430674470428(SNode thisNode) {
    List<SNode> newWords = new ArrayList<SNode>();
    for (SNode word : ListSequence.fromList(SLinkOperations.getTargets(thisNode, "words", true))) {
      if (SNodeOperations.isInstanceOf(word, "de.slisson.mps.richtext.structure.Word") && SNodeOperations.isInstanceOf(ListSequence.fromList(newWords).last(), "de.slisson.mps.richtext.structure.Word")) {
        // Merge two consecutive 'Word's 
        String leftText = SPropertyOperations.getString(SNodeOperations.cast(ListSequence.fromList(newWords).last(), "de.slisson.mps.richtext.structure.Word"), "escapedValue");
        String rightText = SPropertyOperations.getString(SNodeOperations.cast(word, "de.slisson.mps.richtext.structure.Word"), "escapedValue");
        if (leftText == null) {
          leftText = "";
        }
        if (rightText == null) {
          rightText = "";
        }
        SPropertyOperations.set(SNodeOperations.cast(ListSequence.fromList(newWords).last(), "de.slisson.mps.richtext.structure.Word"), "escapedValue", leftText + "" + rightText);

      } else {
        // Always a 'Word' between two embedded nodes 
        if (!(SNodeOperations.isInstanceOf(word, "de.slisson.mps.richtext.structure.Word")) && !(SNodeOperations.isInstanceOf(ListSequence.fromList(newWords).last(), "de.slisson.mps.richtext.structure.Word"))) {
          ListSequence.fromList(newWords).addElement(SConceptOperations.createNewNode("de.slisson.mps.richtext.structure.Word", null));
        }
        // Everything is fine 
        ListSequence.fromList(newWords).addElement(word);
      }
    }

    // End with a word 
    if (!(SNodeOperations.isInstanceOf(ListSequence.fromList(newWords).last(), "de.slisson.mps.richtext.structure.Word"))) {
      ListSequence.fromList(newWords).addElement(SConceptOperations.createNewNode("de.slisson.mps.richtext.structure.Word", null));
    }

    ListSequence.fromList(SLinkOperations.getTargets(thisNode, "words", true)).clear();
    ListSequence.fromList(SLinkOperations.getTargets(thisNode, "words", true)).addSequence(ListSequence.fromList(newWords));
  }

  public static boolean call_isNormalized_842294157794126645(SNode thisNode) {
    // contains at least one child 
    if (ListSequence.fromList(SLinkOperations.getTargets(thisNode, "words", true)).isEmpty()) {
      return false;
    }
    // starts with a 'Word' 
    if (!(SNodeOperations.isInstanceOf(ListSequence.fromList(SLinkOperations.getTargets(thisNode, "words", true)).first(), "de.slisson.mps.richtext.structure.Word"))) {
      return false;
    }
    // ends with a 'Word' 
    if (!(SNodeOperations.isInstanceOf(ListSequence.fromList(SLinkOperations.getTargets(thisNode, "words", true)).last(), "de.slisson.mps.richtext.structure.Word"))) {
      return false;
    }
    // A 'Word' between two embedded nodes and not two consecutive 'Word's 
    for (SNode word : ListSequence.fromList(SLinkOperations.getTargets(thisNode, "words", true))) {
      if ((SNodeOperations.getNextSibling(word) == null)) {
        continue;
      }
      if (!(SNodeOperations.isInstanceOf(word, "de.slisson.mps.richtext.structure.Word")) ^ SNodeOperations.isInstanceOf(SNodeOperations.getNextSibling(word), "de.slisson.mps.richtext.structure.Word")) {
        return false;
      }
    }

    return true;
  }

  public static void call_ensureNormalized_3868187941957822880(SNode thisNode) {
    if (!(Text_Behavior.call_isNormalized_842294157794126645(thisNode))) {
      Text_Behavior.call_normalizeStructure_5500395430674470428(thisNode);
      if (!(Text_Behavior.call_isNormalized_842294157794126645(thisNode))) {
        throw new RuntimeException("Failed to normalize the Text");
      }
    }
  }

  public static String call_asTextString_4433012599261204757(SNode thisNode) {
    return trim_632zde_a0a0e(ListSequence.fromList(SLinkOperations.getTargets(thisNode, "words", true)).foldLeft("", new ILeftCombinator<SNode, String>() {
      public String combine(String s, SNode it) {
        String w = BehaviorReflection.invokeVirtual(String.class, it, "virtual_toTextString_4433012599261204765", new Object[]{});
        if (w != null) {
          return s + w;
        }
        return s;
      }
    }));
  }

  public static String trim_632zde_a0a0e(String str) {
    return (str == null ? null : str.trim());
  }
}
